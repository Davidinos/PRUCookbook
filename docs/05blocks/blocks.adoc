include::../header.adoc[]

== Building Blocks - Applications

Here are some examples that use the basic PRU building blocks.

The following are resources used in this chapter.

.Resources
* http://www.ti.com/lit/ug/spruhv7b/spruhv7b.pdf[PRU Optimizing C/C++ Compiler, v2.2, User's Guide]
* https://www.ti.com/lit/ug/spruh73p/spruh73p.pdf[AM335x Technical Reference Manual]

=== PWM generator
One of the simplest things a PRU can to is generate a simple
problems starting with a single channel PWM that has a fixed frequency and
duty cycle and ending with a multi channel PWM that the ARM can change
the frequency and duty cycle on the fly.

==== Problem
I want to generate a PWM signal that has a fixed frequency and duty cycle.

==== Solution
The solution is fairly easy, but be sure to check the *Discussion* section
for details on making it work.

Here's the code.

.pwm1.c
[source,c,linenums] 
----
include::code/pwm1.c[]
----

To run this code you need to configure the pin muxes to output the PRU.  If you are on the Black run
[source,bash,linenums] 
----
config-pin P9_31 pruout
----
On the Pocket run
[source,bash,linenums] 
----
config-pin P1_36 pruout
----
Then, tell Makefile which PRU you are compiling for and what your target file is

  bone$ export PRUN=0
  bone$ export TARGET=pwm1

Now you are ready to compile
[source,bash,linenums] 
----
bone$ make
-    Stopping PRU 0
stop
CC	pwm1.c
LD	/tmp/pru0-gen/pwm1.obj
-	copying firmware file /tmp/pru0-gen/pwm1.out to /lib/firmware/am335x-pru0-fw
-    Starting PRU 0
start
----
Now attach and LED (or oscilloscope) to `P9_31` on the Black or `P1.36` on the Pocket.  You should see a squarewave.

==== Discussion
Since this is our first example we'll discuss the many parts in detail.

===== pwm1.c
Here's a line-by-line expanation of the c code.

.Line-by-line of pwm1.c
[cols="1,9"]
|===
|Line|Explantion

|1   |Standard c-header include
|2   |Include for the PRU.  The compiler know where to find this since the Makefile says to look for includes in `/usr/lib/ti/pru-software-support-package`
|3   |The file `resource_table_empty.h` is used by the PRU loader.  Generally we'll use the same file, and don't need to modify it.
|===

Here's what's in `resource_table_empty.h`
.resource_table_empty.c
[source,c,linenums] 
----
include::code/resource_table_empty.h[]
----

.Line-by-line (continuted)
[cols="1,9"]
|===
|Line|Explantion

|5-6 |`__R30` and `__R31` are two variables that refer to the PRU output (`__R30`) and input (`__R31`) registers. 
When you write something to `__R30` it will show up on the corresponding output pins.  
When you read from `__R31` you read the data on the input pins.  
NOTE: Both names begin with two underscore's. Section 5.7.2 of the 
http://www.ti.com/lit/ug/spruhv7b/spruhv7b.pdf[PRU Optimizing C/C++ Compiler, v2.2, User's Guide]
gives more details.
|13    |`CT_CFG.SYSCFG_bit.STANDBY_INIT` is set to `0` to enable the OCP master port. More details on this and thousands of other regesters see the 
https://www.ti.com/lit/ug/spruh73p/spruh73p.pdf[AM335x Technical Reference Manual]. Section 4 is on the PRU and section 4.5 gives details for all the registers.
|15    |This line selects which GPIO pin to toggle.  The table below shows which bits in `__R30` map to which pins
|===

Bit 0 is the LSB.

.Mapping bit positions to pin names
|===
|PRU|Bit|Black pin|Blue pin|Pocket pin

|0  |0  |P9_31    |        |P1.36     
|0  |1  |P9_29    |        |P1.33     
|0  |2  |P9_30    |        |P2.32     
|0  |3  |P9_28    |        |P2.30     
|0  |4  |P9_92    |        |P1.31     
|0  |5  |P9_27    |        |P2.34     
|0  |6  |P9_91    |        |P2.28     
|0  |7  |P9_25    |        |P1.29     
|0  |14 |P8_12    |        |P2.24     
|0  |15 |P8_11    |        |P2.33     
|---|---|---------|--------|----------
|1  |0  |P8_45    |        |          
|1  |1  |P8_46    |        |          
|1  |2  |P8_43    |        |          
|1  |3  |P8_44    |        |          
|1  |4  |P8_41    |        |          
|1  |5  |P8_42    |        |          
|1  |6  |P8_39    |        |          
|1  |7  |P8_40    |        |          
|1  |8  |P8_27    |        |P2.35     
|1  |9  |P8_29    |        |P2.01     
|1  |10 |P8_28    |        |P1.35     
|1  |11 |P8_30    |        |P1.04     
|1  |12 |P8_21    |        |          
|1  |13 |P8_20    |        |          
|1  |14 |         |        |P1.32     
|1  |15 |         |        |P1.30     
|===

Since we are running on PRU 0 we're using `0x0001`, that is bit 0, we'll be toggling `P9_31`.

.Line-by-line (continued again)
[cols="1,9"]
|===
|Line|Explantion

|18  |Here is where the action is.  This line reads `__R30` and then ORs it with `gpio`, setting the bits where there is a 1 in `gpio` and leaving the bits where there is a 0.  Thus we are setting the bit we selected. Finally the new value is written back to `__R30`. 
|19  |`__delay_cycles` is an instrinsic function that delays with number of cycles passed to it. Each cycle is 5ns, and we are delaying 100,000,000 cycles which is 500,000,000ns, or 0.5 seconds. 
|20  |This is like line 18, but `~gpio` inverts all the bits in `gpio` so that where we had a 1, there is now a 0.  This 0 is then ANDed with `__R30` setting the corresponding bit to 0.  Thus we are clearing the bit we selected.
|===

[TIP]
====
You can read more about instrinsics in section 5.11 of the (http://www.ti.com/lit/ug/spruhv7b/spruhv7b.pdf[PRU Optimizing C/C++ Compiler, v2.2, User's Guide].)
====

When you run this code and look at the output you will see something like the following figure.

.Output of pwm1.c with 100,000,000 delays cycles giving a 1s period
image:figures/pwm1.png[pwm1.c output]

Notice the on time (`+Width(1)`) is 500ms, just as we predicted.  The off time is 498ms, which is only 2ms off from our prediction.  The standard deviation is 0, or only 380as, which is 380 * 10^-18^!.

You can see how fast the PRU can run by setting both of the `__delay_cycles` to 0. This results in the next figure.

.Output of pwm1.c with 0 delay cycles
image:figures/pwm2.png[pwm1.c output with 0 delay]

Notice the period is 15ns which gives us a frequency of about 67MHz. At this high frequency the breadboard that I'm using distorts the waveform so it's no longer a squarewave. The _on_ time is 5.3ns and the _off_ time is 9.8ns.  That means `__R30 |= gpio;` took only one 5ns cycle and `__R30 &= ~gpio;` also only took one cycle, but there is also an extra cycle needed for the loop.  This means the compiler was able to implement the while loop in just three 5ns instructions!  Not bad.

We want a square wave, so we need to add a delay to correct for the delay of looping back.

Here's the code that does just that.

.pwm2.c
[source,c,linenums] 
----
include::code/pwm2.c[]
----

The output now looks like:
.Output of pwm2.c corrected delay (`pwm3.png`)
image:figures/pwm3.png[pwm2.c corrected delay]

It's not hard to adjust the two `__delay_cycles` to get the desired frequency and duty cycle.

### Controlling the PWM Frequency
#### Problem
You would like to control the frequency and duty cycle of the PWM without recompiling.

#### Solution
Have the PRU read the _on_ and _off_ times from a shared memory location.  Each PRU has is own 8KB of data memory (DRAM) and 12KB of shared memory (SHAREDMEM) that the ARM processor can also access.

.PRU Block Diagram
image:figures/blockDiagram.png[PRU Block diagram]

The DRAM 0 address is 0x0000 for PRU 0.  The same DRAM appears at address 0x4A300000 as seen from the ARM processor.
[TIP]
====
See page
184 of the https://www.ti.com/lit/ug/spruh73p/spruh73p.pdf[AM335x Technical Reference Manual]).  
====
We take the previous PRU and add the lines

[source,c,linenums] 
----
#define PRU0_DRAM		0x00000			// Offset to DRAM
unsigned int *pru0_dram = PRU0_DRAM;
----
to define a pointer to the DRAM.  Later we use

[source,c,linenums] 
----
		pru0_dram[ch] = on[ch];		// Copy to DRAM0 so the ARM can change it
		pru0_dram[ch+MAXCH] = off[ch];	// Copy oafter the on array
----
to write the `on` and `off` times to the DRAM.  Then inside the `while` loop we use
[source,c,linenums] 
----
				onCount[ch] = pru0_dram[2*ch];		// Read from DRAM0
				offCount[ch]= pru0_dram[2*ch+1];
----
to read from the DRAM when reseting the counters.  Now, while the PRU is running, the ARM can write values into the DRAM and change
the PWM on and off times.  Here's the whole code:

.pwm4.c
[source,c,linenums] 
----
include::code/pwm4.c[pwm4.c]
----
Here is code that runs on the ARM side to set the on and off time values.

.pwm-test.c
[source,c,linenums] 
----
include::code/pwm-test.c[pwm-test.c]
----

A check check on the 'scope shows:

.pwm4.png PWM with ARM control
image:figures/pwm4.png[pwm4.png]

From the 'scope you see a 1 cycle on time results in a 450ns wide pulse and
a 3.06us period is .326KHz  Much
slower than the 10ns pusle we saw before.  But it may be more than fast enough
for manny applicaions.  For example, most servos run at 50Hz.

But we can do better.

=== Loop Unrolling for Better Performance
==== Problem
The ARM controlled code runs too slowly.

==== Solution
Simple loops unrolling can greatly improve the speed.  `pwm5.c` is our unrolled
version.

.pwm5.c Unrolled
[source,c,linenums]
----
include::code/pwm5.c[pwm5.c]
----

The output of `pwm5.c` is in the figure below.

.pwm5.c Unrolled version of pwm4.c
image:figures/pwm5 - no loop.png[pwm5.c Unrolled version of pwm4.c]

It's running about 6 times faster than `pwm4.c`.

.pwm4.c vs. pwm5.c
|===
|Measure|pwm4.c time|pwm5.c time|Speedup|pwm5.c w/o UNROLL|Speedup

|Period|3.06&mu;s   |510ns      |6x     |1.81&mu;s      |~1.7x
|Width+|450ns       |70ns       |~6x    |1.56&mu;s      |~.3x
|===

Not a bad speed up for just a couple of simple changes.

==== Discussion
Here's how it works.
First look at line 39.  You see `#pragma UNROLL(MAXCH)` which is a `pragma`
that tells the compiler to unroll the loop that follows.  We are unrolling it
`MAXCH` times (four times in this example). Just removing the `pragma` causes
the speedup compared to the `pwm4.c` case to drop from 6x to only 1.7x.  

We also have our `for` loop inside the `while` loop that can be unrolled.
Unfortunately `UNROLL()` doesn't work on it, therefore we have to do it by
hand. We could take the loop and just copy it three times, but that would
make it harder to maintain the code.  Instead I convered the loop into a 
`#define` (lines 14-24) and invoked `update()` as needed (lines 48-51).
This is not a function call. Whenever the preprocessor sees the `update()` 
it copies the code an then it's compiled.

This unrolling gets us an impressive 6x speedup.

=== Making All the Pulses Start at the Same Time
==== Problem
I have a mutlichannel PWM working, but the pulses aren't synchronized, that is
they don't all start at the same time.

==== Solution
The figure below is a zoomed in version of the previous figure. Notice the pulse in each channel starts about 15ns later than the channel above 
it.

.pwm5 Zoomed In 
image:figures/pwm5 zoomed.png[pwm5 zoomed.png]

The solution is to declare `Rtmp` (line 35) which holds the value for `__R30`.

.pwm6.c Sync'ed Version of pwm5.c 
[source,c,linenums]
----
include::code/pwm6.c[pwm6.c Sync'ed Version of pwm5.c]
----

Each channel writes it's value to `Rtmp` (lines 17 and 20) and then after
each channel has updated, `Rtmp` is copied to `__R30` (line 54).

==== Discussion
The following figure shows the channel are sync'ed. Though the period is slightly
longer than before.

.pwm6 Synchronized Channels
image:figures/pwm6 synced.png[pwm6 Synchronized Channels]


=== Sine Wave Generator
=== Ultrasonic Sensor Application
=== neoPixel driver
