include::../header.adoc[]

== Building Blocks - Applications

Here are some examples that use the basic PRU building blocks.

The following are resources used in this chapter.

.Resources
* http://www.ti.com/lit/ug/spruhv7b/spruhv7b.pdf[PRU Optimizing C/C++ Compiler, v2.2, User's Guide]
* https://www.ti.com/lit/ug/spruh73p/spruh73p.pdf[AM335x Technical Reference Manual]
* http://exploringbeaglebone.com/[Exploring BeagleBone by Derek Molloy]

include::../copyright.adoc[copyright]

=== Memory Allocation

==== Problem
I want to control where my variables are stored in memory.

==== Solution
Each PRU has is own 8KB of data memory (Data Mem0 and Mem1) and 12KB of shared memory (Shared RAM) as shown in <<blocks_PRU_block_diagram>>.

[[blocks_PRU_block_diagram]]
.PRU Block Diagram
image:figures/blockDiagram.png[PRU Block diagram]

Each PRU accesses it's own DRAM starting at location 0x0000_0000. Each PRU
can also access the other PRU's DRAM starting at 0x0000_2000. Both PRUs 
access the shared RAM at 0x0001_0000. The compiler can control where each 
of these memories variables are stored.

<<blocks_shared>> shows how to allocate seven variable in six different locations.

[[blocks_shared]]
.shared.c - Examples of Using Different Memory Locations
[source,c,linenums]
[subs=+quotes]
----
include::code/shared.c[]
----

==== Discussion
Here's the line-by-line

.Line-byline for shared.c
[cols="1,9"]
|===
|Line |Explanation

|7    |`PRU_SRAM` is defined here.  It will be used later to declare variables
in the `Shared RAM` location of memory.  Section 5.5.2 on page 75 of the
http://www.ti.com/lit/ug/spruhv7b/spruhv7b.pdf[PRU Optimizing C/C++ Compiler, v2.2, User's Guide] gives details of the command.  The `PRU_SHAREDMEM` 
referes to the memory section defined in `AM335x_PRU.cmd` on line 26.  
|8,9  |These are like the previous line except for the DMEM sections.
|16   |Variables declared outside of `main()` are put on the heap.
|17   |Adding `PRU_SRAM` has the variable stored in the shared memory.
|18,19|These are stored in the PRU's local RAM.
|20,21|These lines are for storing in the `.bss` section as declared on
line 74 of `AM335x_PRU.cmd`.
|28-31|All the previous examples direct the compiler to an area in memory
and the compilers figures out what to put where.  With these lines we 
specify the exact location.  Here are start with the PRU_DRAM starting address and add 0x200 to it to avoid
the ((STACK)) and the ((HEAP)).  The advantage of this technique is you can
easily share these variables between the ARM and the two PRUs.
|36,37|Variable declared inside `main()` go on the stack.
|===

[CAUTION]
====
Using the technique of line 28-31 you can put variables anywhere, 
even where the compiler has put them.
Be careful, it's easy to overwrite what the compiler has done
====


=== PWM generator
One of the simplest things a PRU can to is generate a simple
problems starting with a single channel PWM that has a fixed frequency and
duty cycle and ending with a multi channel PWM that the ARM can change
the frequency and duty cycle on the fly.

==== Problem
I want to generate a PWM signal that has a fixed frequency and duty cycle.

==== Solution
The solution is fairly easy, but be sure to check the *Discussion* section
for details on making it work.

Here's the code.

.pwm1.c
[source,c,linenums] 
----
include::code/pwm1.c[]
----

To run this code you need to configure the pin muxes to output the PRU.  If you are on the Black run
[source,bash] 
[subs=+quotes]
----
bone$ *config-pin P9_31 pruout*
----
On the Pocket run
[source,bash] 
[subs=+quotes]
----
bone$ *config-pin P1_36 pruout*
----
Then, tell Makefile which PRU you are compiling for and what your target file is
[source,bash]
[subs=+quotes]
----
bone$ *export PRUN=0*
bone$ *export TARGET=pwm1*
----

Now you are ready to compile
[source,bash,linenums] 
[subs=+quotes]
----
bone$ *make*
-    Stopping PRU 0
stop
CC	pwm1.c
LD	/tmp/pru0-gen/pwm1.obj
-	copying firmware file /tmp/pru0-gen/pwm1.out to /lib/firmware/am335x-pru0-fw
-    Starting PRU 0
start
----
Now attach an LED (or oscilloscope) to `P9_31` on the Black or `P1.36` on the Pocket.  You should see a squarewave.

==== Discussion
Since this is our first example we'll discuss the many parts in detail.

===== pwm1.c
Here's a line-by-line expanation of the c code.

.Line-by-line of pwm1.c
[cols="1,9"]
|===
|Line|Explanation

|1   |Standard c-header include
|2   |Include for the PRU.  The compiler know where to find this since the Makefile says to look for includes in `/usr/lib/ti/pru-software-support-package`
|3   |The file `resource_table_empty.h` is used by the PRU loader.  Generally we'll use the same file, and don't need to modify it.
|===

Here's what's in `resource_table_empty.h`
.resource_table_empty.c
[source,c,linenums] 
----
include::code/resource_table_empty.h[]
----

.Line-by-line (continuted)
[cols="1,9"]
|===
|Line|Explanation

|5-6 |`__R30` and `__R31` are two variables that refer to the PRU output (`__R30`) and input (`__R31`) registers. 
When you write something to `__R30` it will show up on the corresponding output pins.  
When you read from `__R31` you read the data on the input pins.  
NOTE: Both names begin with two underscore's. Section 5.7.2 of the 
http://www.ti.com/lit/ug/spruhv7b/spruhv7b.pdf[PRU Optimizing C/C++ Compiler, v2.2, User's Guide]
gives more details.
|13    |`CT_CFG.SYSCFG_bit.STANDBY_INIT` is set to `0` to enable the OCP master port. More details on this and thousands of other regesters see the 
https://www.ti.com/lit/ug/spruh73p/spruh73p.pdf[AM335x Technical Reference Manual]. Section 4 is on the PRU and section 4.5 gives details for all the registers.
|15    |This line selects which GPIO pin to toggle.  The table below shows which bits in `__R30` map to which pins
|===

Bit 0 is the LSB.

[[blocks_mapping_bits]]
.Mapping bit positions to pin names
|===
|PRU|Bit|Black pin|Blue pin|Pocket pin

|0  |0  |P9_31    |        |P1.36     
|0  |1  |P9_29    |        |P1.33     
|0  |2  |P9_30    |        |P2.32     
|0  |3  |P9_28    |        |P2.30     
|0  |4  |P9_92    |        |P1.31     
|0  |5  |P9_27    |        |P2.34     
|0  |6  |P9_91    |        |P2.28     
|0  |7  |P9_25    |        |P1.29     
|0  |14 |P8_12    |        |P2.24     
|0  |15 |P8_11    |        |P2.33     
|---|---|---------|--------|----------
|1  |0  |P8_45    |        |          
|1  |1  |P8_46    |        |          
|1  |2  |P8_43    |        |          
|1  |3  |P8_44    |        |          
|1  |4  |P8_41    |        |          
|1  |5  |P8_42    |        |          
|1  |6  |P8_39    |        |          
|1  |7  |P8_40    |        |          
|1  |8  |P8_27    |        |P2.35     
|1  |9  |P8_29    |        |P2.01     
|1  |10 |P8_28    |        |P1.35     
|1  |11 |P8_30    |        |P1.04     
|1  |12 |P8_21    |        |          
|1  |13 |P8_20    |        |          
|1  |14 |         |        |P1.32     
|1  |15 |         |        |P1.30     
|===

Since we are running on PRU 0 we're using `0x0001`, that is bit 0, we'll be toggling `P9_31`.

.Line-by-line (continued again)
[cols="1,9"]
|===
|Line|Explanation

|18  |Here is where the action is.  This line reads `__R30` and then ORs it with `gpio`, setting the bits where there is a 1 in `gpio` and leaving the bits where there is a 0.  Thus we are setting the bit we selected. Finally the new value is written back to `__R30`. 
|19  |`__delay_cycles` is an instrinsic function that delays with number of cycles passed to it. Each cycle is 5ns, and we are delaying 100,000,000 cycles which is 500,000,000ns, or 0.5 seconds. 
|20  |This is like line 18, but `~gpio` inverts all the bits in `gpio` so that where we had a 1, there is now a 0.  This 0 is then ANDed with `__R30` setting the corresponding bit to 0.  Thus we are clearing the bit we selected.
|===

[TIP]
====
You can read more about instrinsics in section 5.11 of the (http://www.ti.com/lit/ug/spruhv7b/spruhv7b.pdf[PRU Optimizing C/C++ Compiler, v2.2, User's Guide].)
====

When you run this code and look at the output you will see something like the following figure.

.Output of pwm1.c with 100,000,000 delays cycles giving a 1s period
image:figures/pwm1.png[pwm1.c output]

Notice the on time (`+Width(1)`) is 500ms, just as we predicted.  The off time is 498ms, which is only 2ms off from our prediction.  The standard deviation is 0, or only 380as, which is 380 * 10^-18^!.

You can see how fast the PRU can run by setting both of the `__delay_cycles` to 0. This results in the next figure.

.Output of pwm1.c with 0 delay cycles
image:figures/pwm2.png[pwm1.c output with 0 delay]

Notice the period is 15ns which gives us a frequency of about 67MHz. At this high frequency the breadboard that I'm using distorts the waveform so it's no longer a squarewave. The _on_ time is 5.3ns and the _off_ time is 9.8ns.  That means `__R30 |= gpio;` took only one 5ns cycle and `__R30 &= ~gpio;` also only took one cycle, but there is also an extra cycle needed for the loop.  This means the compiler was able to implement the while loop in just three 5ns instructions!  Not bad.

We want a square wave, so we need to add a delay to correct for the delay of looping back.

Here's the code that does just that.

.pwm2.c
[source,c,linenums] 
----
include::code/pwm2.c[]
----

The output now looks like:
.Output of pwm2.c corrected delay (`pwm3.png`)
image:figures/pwm3.png[pwm2.c corrected delay]

It's not hard to adjust the two `__delay_cycles` to get the desired frequency and duty cycle.

### Controlling the PWM Frequency
#### Problem
You would like to control the frequency and duty cycle of the PWM without recompiling.

#### Solution
Have the PRU read the _on_ and _off_ times from a shared memory location.  Each PRU has is own 8KB of data memory (DRAM) and 12KB of shared memory (SHAREDMEM) that the ARM processor can also access.  See <<blocks_PRU_block_diagram>>.

The DRAM 0 address is 0x0000 for PRU 0.  The same DRAM appears at address 0x4A300000 as seen from the ARM processor.
[TIP]
====
See page
184 of the https://www.ti.com/lit/ug/spruh73p/spruh73p.pdf[AM335x Technical Reference Manual]).  
====
We take the previous PRU and add the lines

[source,c,linenums] 
----
#define PRU0_DRAM		0x00000			// Offset to DRAM
volatile unsigned int *pru0_dram = PRU0_DRAM;
----
to define a pointer to the DRAM. 
[NOTE]
====
The `volatile` keyword is used here to tell the compiler the value this
points to may change, so don't make any assumptions while optimizing.
====
Later in the code we use

[source,c,linenums] 
----
		pru0_dram[ch] = on[ch];		// Copy to DRAM0 so the ARM can change it
		pru0_dram[ch+MAXCH] = off[ch];	// Copy oafter the on array
----
to write the `on` and `off` times to the DRAM.  Then inside the `while` loop we use
[source,c,linenums] 
----
				onCount[ch] = pru0_dram[2*ch];		// Read from DRAM0
				offCount[ch]= pru0_dram[2*ch+1];
----
to read from the DRAM when reseting the counters.  Now, while the PRU is running, the ARM can write values into the DRAM and change
the PWM on and off times.  Here's the whole code:

.pwm4.c
[source,c,linenums] 
----
include::code/pwm4.c[pwm4.c]
----
Here is code that runs on the ARM side to set the on and off time values.

.pwm-test.c
[source,c,linenums] 
----
include::code/pwm-test.c[pwm-test.c]
----

A check check on the 'scope shows:

.pwm4.png PWM with ARM control
image:figures/pwm4.png[pwm4.png]

From the 'scope you see a 1 cycle on time results in a 450ns wide pulse and
a 3.06us period is .326KHz  Much
slower than the 10ns pusle we saw before.  But it may be more than fast enough
for manny applicaions.  For example, most servos run at 50Hz.

But we can do better.

=== Loop Unrolling for Better Performance
==== Problem
The ARM controlled code runs too slowly.

==== Solution
Simple loops unrolling can greatly improve the speed.  `pwm5.c` is our unrolled
version.

.pwm5.c Unrolled
[source,c,linenums]
----
include::code/pwm5.c[pwm5.c]
----

The output of `pwm5.c` is in the figure below.

.pwm5.c Unrolled version of pwm4.c
image:figures/pwm5 - no loop.png[pwm5.c Unrolled version of pwm4.c]

It's running about 6 times faster than `pwm4.c`.

.pwm4.c vs. pwm5.c
|===
|Measure|pwm4.c time|pwm5.c time|Speedup|pwm5.c w/o UNROLL|Speedup

|Period|3.06&mu;s   |510ns      |6x     |1.81&mu;s      |~1.7x
|Width+|450ns       |70ns       |~6x    |1.56&mu;s      |~.3x
|===

Not a bad speed up for just a couple of simple changes.

==== Discussion
Here's how it works.
First look at line 39.  You see `#pragma UNROLL(MAXCH)` which is a `pragma`
that tells the compiler to unroll the loop that follows.  We are unrolling it
`MAXCH` times (four times in this example). Just removing the `pragma` causes
the speedup compared to the `pwm4.c` case to drop from 6x to only 1.7x.  

We also have our `for` loop inside the `while` loop that can be unrolled.
Unfortunately `UNROLL()` doesn't work on it, therefore we have to do it by
hand. We could take the loop and just copy it three times, but that would
make it harder to maintain the code.  Instead I convered the loop into a 
`#define` (lines 14-24) and invoked `update()` as needed (lines 48-51).
This is not a function call. Whenever the preprocessor sees the `update()` 
it copies the code an then it's compiled.

This unrolling gets us an impressive 6x speedup.

=== Making All the Pulses Start at the Same Time
==== Problem
I have a mutlichannel PWM working, but the pulses aren't synchronized, that is
they don't all start at the same time.

==== Solution
The figure below is a zoomed in version of the previous figure. Notice the pulse in each channel starts about 15ns later than the channel above 
it.

.pwm5 Zoomed In 
image:figures/pwm5 zoomed.png[pwm5 zoomed.png]

The solution is to declare `Rtmp` (line 35) which holds the value for `__R30`.

.pwm6.c Sync'ed Version of pwm5.c 
[source,c,linenums]
----
include::code/pwm6.c[pwm6.c Sync'ed Version of pwm5.c]
----

Each channel writes it's value to `Rtmp` (lines 17 and 20) and then after
each channel has updated, `Rtmp` is copied to `__R30` (line 54).

==== Discussion
The following figure shows the channel are sync'ed. Though the period is slightly
longer than before.

.pwm6 Synchronized Channels
image:figures/pwm6 synced.png[pwm6 Synchronized Channels]


=== Adding More Channels via PRU 1
==== Problem
You need more output channels, or you need to shorten the period.

==== Solution
PRU 0 can output up to eight output pins (see 
<<#bit_positions,Mapping bit position to pin names>>). The code presented so far
can be easily extended to use the eight output pins.

But what if you need more channels?
You can always use PRU1, it has 14 output pins.

Or, what if four channels is enough, but you need a shorter period. Everytime
you add a channel, the overall period gets longer.  Twice as many channels 
means twice as long a period.  If you move half the channels to PRU 1, you
will make the period half as long.

Here's the code (`pwm7.c`)

.pwm7.c Using Both PRUs
[source,c,linenums]
----
include::code/pwm7.c[pwm7.c Using Both PRUs]
----

Be sure to run `pwm7_setup.sh` to get the coffect pins configured.
.pwm7_setup.sh
----
include::code/pwm7_setup.sh[pw7_setup.sh]
----
This makes sure the PRU 1 pins are properly configured.

Then compile and run with
[source,bash]
[subs=+quotes]
----
bone$ *make PRUN=0; make PRUN=1*
-    Stopping PRU 0
stop
CC	pwm7.c
LD	/tmp/pru0-gen/pwm7.obj
-	copying firmware file /tmp/pru0-gen/pwm7.out to /lib/firmware/am335x-pru0-fw
-    Starting PRU 0
start
-    Stopping PRU 1
stop
CC	pwm7.c
LD	/tmp/pru1-gen/pwm7.obj
-	copying firmware file /tmp/pru1-gen/pwm7.out to /lib/firmware/am335x-pru1-fw
-    Starting PRU 1
start
----
This will first stop, compile and start PRU 0, then do the same for PRU 1.

Moving half of the channels to PRU1 dropped the period from 510ns to 370ns, so
we gained a bit.

==== Discussion
There weren't many changes to be made.  Line 13 we set MAXCH to 2. Lines 43-46
is where the big change is.
[source,c]
----
		pru0_dram[2*ch  ] = on [ch+PRUN*MAXCH];	// Copy to DRAM0 so the ARM can change it
		pru0_dram[2*ch+1] = off[ch+PRUN*MAXCH];	// Interleave the on and off values
		onCount[ch] = on [ch+PRUN*MAXCH];
		offCount[ch]= off[ch+PRUN*MAXCH];
----
The Makefile sets `PRUN` to be the number of the PRU we are compiling for.  If 
we are compiling for PRU 0, `on[ch+PRUN*MAXCH]` becomes `on[ch+0*2]` which is
`on[ch]` which is what we had before.  But now if we are on PRU 1 it becomes
`on[ch+1*2]` which is `on[ch+2]`.  That means we are picking up the second 
half of the `on` and `off` arrays.  The first half goes to PRU 0, the second to
PRU 1.  So the same code can be used for both PRUs, but we get slightly different 
behavior.

Running the code you will see the next figure.

.pwm7 Two PRUs running
image:figures/pwm7 two prus running.png[pwm7 Two PRUs running]

What's going on there, the first channels look fine, but the PRU 1 channels
are blurred.  To see what's happening, let's stop the oscilloscope.

.pwm7 Two PRUs stopped
image:figures/pwm7 two prus stopped.png[pwm7 Two PRUs stopped]

The stopped display shows that the four channels are doing what we wanted, except 
The PRU 0 channels have a period of 370ns while the PRU 1 channels at 330ns.
It appears the compiler has optimied the two PRUs slightly differenty.


=== Sychronziing Two PRUs
==== Problem
I need to synchronize the two PRUs so they run together.

==== Solution
Use the Interrupt Controller (INTC).  It allows one PRU to signal the other.
Page 225 of the 
https://www.ti.com/lit/ug/spruh73p/spruh73p.pdf[AM335x Technical Reference Manual]
has details of how it works.  Here's the code (`pwm8.c`).

.pwm8.c Using INTC to signal from one PRU to the other
[source,c,linenums]
----
include::code/pwm8.c[pwm8.c Using INTC to signal from one PRU to the other]
----

In `pwm8.c` PRU 1 waits for a signal from PRU 0, so be sure to start PRU 1 first.
`bone$ *make PRUN=1; make PRUN=0*

==== Discussion
The figure below shows the two PRUs are synchronized, though there is some extra
overhead in the process so the period is longer.

.pwm8 PRUs sycned
image:figures/pwm8 prus sycned.png[pwm8 PRUs sycned]

This isn't much different from the previous examples.
.pwm8.c changes from pwm7.c 
[cols="1,9"]
|===
|Line|Change

|32-45|For PRU 0 these define `configInitc()` which initializes the interupts.
See page 226 of the 
https://www.ti.com/lit/ug/spruh73p/spruh73p.pdf[AM335x Technical Reference Manual]
for a diagram explaining events, channels, hosts, etc.
|55-58|Set a configuration register and call `configInitc`.
|73-77|PRU 1 then waits for PRU 0 to signal it.  Bit 31 of `__R31` corresponds
to the Host-1 channel which `configInitc()` set up. We also clear event 16 so 
PRU 0 can set it again.
|81-84|On PRU 0 this generates the interupt to send to PRU 1.  I found PRU 1 was 
slow to respond to the interupt, so I put this code at the end of the loop to
give time for the signal to get to PRU 1.
|===

=== Reading an Input at Regular Intervals
==== Problem
You have an input pin that needs to be read at regular intervals.

==== Solution
You can use the `__R31` register to read an input pin. Let's use the following
pins.
[[blocks_io_pins]]
.Input/Output pins
|===
|Direction|Bit number|Black|Pocket
|out      |0         |P9_31|P1.36
|in       |7         |P9_25|P1.29
|===
These values came from <<blocks_mapping_bits>>.

Configure the pins with `input_setup.sh`.

.input_setup.sh
[source,bash,linenums]
----
include::code/input_setup.sh[]input_setup.sh]
----

The following code reads the input pin and writes its value to the output pin.
.input1.c
[source,c,linenums]
----
include::code/input1.c[input1.c]
----

==== Discussion


=== Analog Wave Generator
==== Problem
I want to generate an analog output, but only have GPIO pins.

==== Solution
The Beagle doesn't have a built in  analog to digital converter. You could
get a https://www.amazon.com/external-Adapter-Windows-Microphone-SD-CM-UAUD/dp/B001MSS6CS/0&keywords=audio+dongle[USB Audio Dongle] which are under $10.  But here
we'll take another approach.

Earlier we generated a PWM signal.  Here we'll generate a PWM whose duty cycle
changes with time.  A small duty cycle for when the output signal is small and
a large dudty cycle for when it is large.

This example was inspired by _A PRU Sin Wave Generator_ in chapter 13 of 
http://exploringbeaglebone.com/[Exploring BeagleBone by Derek Molloy].

Here's the code.

.sine1.c
[source,c,linenums]
[subs=+quotes]
----
include::code/sine1.c[since1.c]
----
Set the `#define` at line 7 to the number of samples in one cycle of the waveform 
and get the `#define` at line 8 to which waveform and then run `make`.

==== Discussion
The code has two parts.  The first part (lines 21 to 39) generate the waveform
to be output. The ``#define``s let you select which waveform you want to
generate.  Since the output is a percent duty cycle, the values in `waveform[]` 
must be between 0 and 100 inclusive. The waveform is only generated once, so
this part of the code isn't time critical.

The second part (lines 44 to 54) uses the generated data to set the
duty cycle of the PWM on a cycle-by-cycle basis. This part is time critical; 
the faster we can output the values, the higher the frequency of the output 
signal.

Suppose you want to generate a sawtooth waveform like the one shown in <<blocks_sawtooth>>.

[[blocks_sawtooth]]
.Continuous Sawtooth Waveform
image:figures/sawtoothsmooth.png[Continuous Sawtooth Waveform]

You need to sample the waveform and store one cycle. <<blocks_sawtoothsampled>>
shows a sampled version of the sawtooth. You need to generate `MAXT` samples; 
here we show 20 samples, which may be enough. In the code `MAXT` is set to 100.

[[blocks_sawtoothsampled]]
.Sampled Sawtooth Waveform
image:figures/sawtoothsampled.png[Sampled Sawtooth Waveform]

There's a lot going on here; let's take it line by line.

.Line-by-line of sine1.c
[cols="1,9"]
|===
|Line |Explanation

|2-5  |Standard c-header includes
|7    |Number for samples in one cycle of the analog waveform
|9    |Which waveform to use.  We've defined SAWTOOTH, TRIANGLE and SINE, but
you can define your own too.
|10-11|Declaring registers `_R30` and `_R31`.
|15-16|`onCount`	 how many cycles the PWM should be 1 and `offCount` counts
how many it should be off.
|18   |`waveform[]` stores the analog waveform being ouput.
|21-24|`SAWTOOTH` is the simplest of the waveforms. Each sample is the duty cycle 
at that time and must therefore be between 0 and 100. 
|26-31|`TRIANGLE` is also a simple waveform.  
|32-39|`SINE` generates a sine wave and also introduces floating point.  Yes, you can use floating point, but the PRUs don't have floating point hardware, 
rather, it's all done in software.  This mean using floating point will make
your code much bigger and slower.  Slower doesn't matter in this part, and 
bigger isn't bigger than our instruction memory, so we're OK.
|47   |Here the for loop looks up each value of the generated waveform.
|48,49|`onCount` is the number of cycles to be at 1 and `offCount` is the number 
of cycles to be 0. The two add to 100, one full cycle.
|50-52|Stay on for `onCount` cycles.
|53-55|No turn off for `offCount` cycles, the loop back and look up the next 
cycle count.
|===

<<blocks_sawunfiltered>> shows the output of the code. 

[[blocks_sawunfiltered]]
.Unfiltered Sawtooth Waveform
image:figures/sawunfiltered.png[Unfiltered Sawtooth Waveform]

It doesn't look like a sawtooth; but if you look at the left side you will 
see each cycle has a longer and longer on time.  The duty cycle is increasing.
Once it's almost 100% duty cycle, it switches to a very small duty cycle.
Therefore it's output what we programmed, but what we want is the average of 
the signal.  The left had side has a large (and increasing) average which 
would be for top of the sawtooth.  The right hand side has a small average,
which is what you want for the start of the sawtooth.

A simple low-pass filter, built with one resistor and one capacitor will do it.
<<blocks_filter>> shows how to wire it up.

[[blocks_filterwiring]]
.Low-Pass Filter Wiring Diagram
image:figures/filter_bb.png[Low-Pass Filter Wiring Diagram]

[NOTE]
====
I used a 10K&Omega; variable resistor and a 0.022&mu;F capacitor. (The figure
has the wrong value.) Probe the circuit between the resistor and the capacitor andI adjust the resistor until you get a good looking waveform.
====

<<blocks_sawscope>> shows the results for filtered the SAWTOOTH.

[[blocks_sawscope]]
.Reconstructed Sawtooth Waveform
image:figures/sawscope.png[Reconstructed Sawtooth Waveform, width=500]

Now that look more like a sawtooth wave.  The top plot is the time-domain
plot of the output of the low-pass filter. The bottom plot is the FFT of the top 
plot, therefore it's the frequency domain. We are getting a sawtooth with a
frequency of about 6.1KHz. You can see the fundamental frequency on the 
bottom plot along with several harmonics.


The top looks like a sawtooth wave, 
but there is a high freqnecy superimposed on it.  We are only using a simple 
first-order filter.  You could lower the cutoff freqnecy by adjusting the
resistor.  You'll see something like <<blocks_lowercutoff>>.

[[blocks_lowercutoff]]
.Reconstructed Sawtooth Waveform with Lower Cutoff Frequency
image:figures/sawlowercutoff.png[Reconstructed Sawtooth Waveform with Lower Cutoff Frequency]

The high freqencies have been reduced, but the corner of the waveform has 
been rounded.  You can also adjust the cutoff to a higher frequency and you'll 
get a sharper corner, but you'll also get more high frequencies. See 
<<blocks_highercutoff>>

[[blocks_highercutoff]]
.Reconstructed Sawtooth Waveform with Higher Cutoff Frequency
image:figures/sawhighercutoff.png[Reconstructed Sawtooth Waveform with Higher Cutoff Frequency]

Adjust to taste, though the real solution is to build a higher order filter. 
Search for _second order filter_ and you'll find some nice circuits.

You can adjust the frequency of the signal by adjesting `MAXT`.  A smaller 
`MAXT` will give a higher frequency.  I'm gotten good results with `MAXT` 
as small as 20.

You can also get a triangle waveform by setting the `#define`. 
<<blocks_triangle>> shows the output signal.

[[blocks_triangle]]
.Reconstructed Triangle Waveform
image:figures/triangle.png[Reconstructed Triangle Waveform]

And also the sine wave as shown in <<blocks_sine>>.

[[blocks_sine]]
.Reconstructed Sinusoid Waveform
image:figures/sine.png[Reconstructed Sinusoid Waveform]

Notice on the bottom plot the harmonics are much more suppressed.

Generating the sine waveform uses ((floats)). This requires much more code.
You can look in `/tmp/pru0-gen/sine1.map` to see how much memory is being used.
<<blocks_sine1_map>> shows the first few lines for the sine wave.

[[blocks_sine1_map]]
./tmp/pru0-gen/sine1.map for Sine Wave
[source,bash,linenums]
----
include::code/sine1.map[lines=1..22]
----

Notice line 19 shows 0x18c0 bytes are being used for instructions.  That's 6336 
in decimal.

Now compile for the sawtooth and you see only 444 byes are used.  Floating-point 
requires over 5K more bytes.  Use with care.  If you are short on instruction
space, you can move the table generation to the ARM and just copy the table
to the PRU.


=== Ultrasonic Sensor Application

=== neoPixel driver

=== Copyright
[source,c,linenums]
.copyright.c
----
include::code/copyright.c[copyright.c]
----