include::../header.adoc[]

== More Performance

So far in all our examples we've been able to meet our timing goals by writing
our code in the C programming language. The C compiler does a suprisingly
good job at generating code, most the time.  However there are times
when very precise timing is needed and the compiler isn't doing it.

At these times you need to write in assembly language.  This chapter
introduces the PRU assembler and shows how to call assembly code from
C.

The following are resources used in this chapter.

.Resources
* http://www.ti.com/lit/ug/spruhv7b/spruhv7b.pdf[PRU Optimizing C/C++ Compiler, v2.2, User's Guide]
* http://www.ti.com/lit/ug/spruhv6b/spruhv6b.pdf[PRU Assembly Language Tools User's Guide]
* http://www.ti.com/lit/ug/spruij2/spruij2.pdf[PRU Assembly Instruction User Guide]

=== Calling Assembly from C
==== Problem
You have some C code and you want to call an assembly language routine from
it.

==== Solution
You need to do two things, write the assembler file and modify the Makefile
to include it. For example, let's write our own `my_delay_cycles` routine in
in assembly.  The intrinsic `__delay_cycles` must be passed a compile time
constant.  Our new `delay_cycles` can take a runtime delay value.

<<more_delay-test>> is much like our other c code, but one line 9 we declare `my_delay_cycles` and then on line 23 and 25 well call it with an argument
of 1.
[[more_delay-test]]
.test-delay.c
[source,c,linenums]
[subs=+quotes]
----
include::code/delay-test.c[]
----

<<more_delay>> is the assembly code.
[[more_delay]]
.delay.asm
[source,c,linenums]
[subs=+quotes]
----
include::code/delay.asm[]
----

You then need to compile with <<more_makefile>>.
[[more_makefile]]
.Makefile
[source,makefile,linenums]
[subs=+quotes]
----
include::code/Makefile[]
----

The resulting output is shown in <<more_my_delay_cycles>>.

[[more_my_delay_cycles]]
.Output of my_delays_cycles()
image:figures/my_delay_cycles.png[Output of my_delays_cycles()]

Notice the on time is about 35ns and the off time is 30ns.

==== Discission
There is much to explain here.  Let's start with <<more_delay>>.

.Line-by-line of delays.asm
[cols="1,9"]
|===
|Line |Explanation

|3    |Declare `my_delay_cycles` to be global so the linker can find it.
|4    |Label the starting point for `my_delay_cycles`.
|5    |Label for our delay loop.
|6    |The first argument is passed in register `r14`.  Page 111 of
http://www.ti.com/lit/ug/spruhv7b/spruhv7b.pdf[PRU Optimizing C/C++ Compiler, v2.2, User's Guide]
gives the argument passing convention.  Registers `r14` to `r29` are used
to pass arguments, if there are more arguments, the argument stack (`r4`)
is used.  The other register conventions are found on page 108.
Here we subtract 1 from `r14` and save it back into `r14`.
|7    |`qbne` is a quick branch if not equal.
|9    |Once we've delayed enough we drop through the quick branch and 
hit the jump.  The upper bits of register `r3` has the return address,
therefore we return to the c code.
|===

The Makefile (<<more_makefile>>) has just a couple of additions.  First
`TARGETasm` is the name of the assembler file.  Generally this is set
outside with Makefile with `export TARGETasm=delay`.  Line 49 has the
bold part added of the assmbler output is also linked in.

[source,bash]
[subs=+quotes]
----
$(GEN_DIR)/$(TARGET).out: $(GEN_DIR)/$(TARGET).obj *$(GEN_DIR)/$(TARGETasm).obj*

----

Finally lines 58-61 are added to assemble the `TARGETasm` file.

[source,bash]
[subs=+quotes]
----
$(GEN_DIR)/$(TARGETasm).obj: $(TARGETasm).asm
	@mkdir -p $(GEN_DIR)
	@echo 'CC	$<'
	@clpru --include_path=$(PRU_CGT)/include $(INCLUDE) $(CFLAGS) -D=PRUN=$(PRUN) -fe $@ $<
----

The following will compile and run everything.
[source,bash]
[subs=+quotes]
----
bone$ *export PRUN=0*
bone$ *export TARGET=delay-test*
bone$ *export TARGETasm=delay*
bone$ *config-pin $pin pruout*
bone$ *make*
-    Stopping PRU 0
stop
CC	delay-test.c
CC	delay.asm
LD	/tmp/pru0-gen/delay-test.obj /tmp/pru0-gen/delay.obj
-	copying firmware file /tmp/pru0-gen/delay-test.out to /lib/firmware/am335x-pru0-fw
-    Starting PRU 0
start
----

<<more_my_delay_cycles>> shows the on time is 35ns and the off time is 30ns.
With 5ns/cycle this give 7 cycles on and 6 off. These times make sense 
because each instruction takes a cycle and you have, set R30, jump to
`my_delay_cycles`, sub, qbne, jmp. Plus the instruction (not seen) that
initilizes `r14` to the passed value.  That's a total of six instructions.
The extra instruction is the branch at the bottom of the `while` loop.

=== Returning a Value from Assembly
==== Problem
Your assembly code needs to return a value.

==== Solution
`R14` is how the return value is passed back.  <<more_test2>> shows the c
code.

[[more_test2]]
.test-delay2.c
[source,c,linenums]
[subs=+quotes]
----
include::code/delay-test2.c[]
----

<<more_delay2>> is the assembly code.
[[more_delay2]]
.delay2.asm
[source,c,linenums]
[subs=+quotes]
----
include::code/delay2.asm[]
----

An additional feature is shown in line 4 of <<more_delay2>>.  The
`.cdecls "delay-test2.c"` says to include any defines from `delay-test2.c`
In this example, line 6 of <<more_test2>> #defines TEST and line 12 of 
<<more_delay2>> reference it.

=== Copyright
[source,c,linenums]
.copyright.c
----
include::code/copyright.c[copyright.c]
----